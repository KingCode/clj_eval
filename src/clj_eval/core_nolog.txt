(ns clj-eval.core
  (:require [clj-eval.util :refer [log] :as u]))

(defn my-eval [env exp]
    (letfn [(eval-list [env [op & args :as exp]]
                (if (= 'let op)
                    (eval-let env exp)
                    (let [ vargs (vec (map #(my-eval env %) args))]
                        (condp = op
                            'if (if (vargs 0) (vargs 1) (vargs 2))

                            'do (do (doall vargs) 
                                    (last vargs))

                            (let [op (my-eval env op)]
                                (if (fn? op) (apply op vargs)
                                    (cons op vargs)))))))

            (eval-let [env [_ bindings & body]]
              (->> (apply list 'do body)
                   (my-eval (apply assoc env 
                                   (let-resolve env bindings)))))
              
            (let-resolve [env lbexps]
                            (->> (partition 2 lbexps) 
                                (map (fn [[bk bexp]]
                                        [bk (my-eval env bexp)]))
                                (apply concat) 
                                vec)) ] 
  (cond 
     (symbol? exp) (get env exp exp)
     (seq? exp) (eval-list env exp)
     (coll? exp) (into (empty exp) (map #(my-eval env %) exp))
     :else exp)))
